var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Exercise1","category":"page"},{"location":"#Exercise-1","page":"Home","title":"Exercise 1","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This exercise 1 from https://github.com/ubcecon/ECON622/blob/master/notebooks/numericallinearalgebra.ipynb","category":"page"},{"location":"","page":"Home","title":"Home","text":"This exercise is for a practice on writing low-level routines (i.e. “kernels”), and to hopefully convince you to leave low-level code to the experts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The formula for matrix multiplication is deceptively simple.  For example, with the product of square matrices $ C = A B $ of size $ N \\times N $, the $ i,j $ element of $ C $ is","category":"page"},{"location":"","page":"Home","title":"Home","text":"C_ij = sum_k=1^N A_ik B_kj","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can take a row $ A{i,:} $ and column $ B{:, j} $ and use an inner product","category":"page"},{"location":"","page":"Home","title":"Home","text":"C_ij = A_i cdot B_j","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the inner product in a discrete space is simply a sum, and has the same complexity as the sum (i.e. $ O(N) $ operations).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a dense matrix without any structure, this also makes it clear why the complexity is $ O(N^3) $: you need to evaluate it for $ N^2 $ elements in the matrix and do an $ O(N) $ operation each time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this exercise, implement matrix multiplication yourself and compare performance in a few permutations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the built-in function in Julia (i.e.C = A * B or, for a better comparison, the inplace version mul!(C, A, B) which works with preallocated data)  \nLoop over each $ C_{ij} $ by the row first (i.e. the i index) and use a for loop for the inner product  \nLoop over each $ C_{ij} $ by the column first (i.e. the j index) and use a for loop for the inner product  \nDo the same but use the dot product instead of the sum.  \nChoose your best implementation of these, and then for matrices of a few different sizes N=10, N=1000, etc. and compare the ratio of performance of your best implementation to the built in BLAS library.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A few more hints:","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can just use random matrices, e.g. A = rand(N, N), etc.  \nFor all of them, preallocate the $ C $ matrix beforehand with C = similar(A) or something equivalent.  \nTo compare performance, put your code in a function and use @btime macro to time it.  Remember to escape globals if necessary (e.g. @btime f(\\$A) rather than @btime f(A)  Documentation for Exercise1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Exercise1\nusing BenchmarkTools\nn = 100\nA = randn(n,n)\nB = randn(n,n)\nC = similar(B)\n\n@btime rowmatmul!($C,$A,$B)\n@btime colmatmul!($C,$A,$B)\n@btime matmul!($C,$A,$B)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Exercise1]","category":"page"},{"location":"#Exercise1.rowmatmul!-Tuple{Any, Any, Any}","page":"Home","title":"Exercise1.rowmatmul!","text":"rowmatmul!(C, A, B)\n\nSet C = A*B, looping over rows first   \n\n\n\n\n\n","category":"method"}]
}
